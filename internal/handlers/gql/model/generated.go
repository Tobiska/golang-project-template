// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type GroupCreateResult interface {
	IsGroupCreateResult()
}

type GroupFindResult interface {
	IsGroupFindResult()
}

type GroupResolvingResult interface {
	IsGroupResolvingResult()
}

type ProblemInterface interface {
	IsProblemInterface()
}

type TokenResolvingResult interface {
	IsTokenResolvingResult()
}

type UserCreateResult interface {
	IsUserCreateResult()
}

type UserFindResult interface {
	IsUserFindResult()
}

type UserResolvingResult interface {
	IsUserResolvingResult()
}

type UserSignInResult interface {
	IsUserSignInResult()
}

type EmailValidationProblem struct {
	Message string `json:"message"`
}

func (EmailValidationProblem) IsProblemInterface()    {}
func (EmailValidationProblem) IsUserResolvingResult() {}

type Group struct {
	UUID    string `json:"uuid"`
	Name    string `json:"name"`
	OwnerID int    `json:"ownerId"`
	Owner   *User  `json:"owner"`
}

func (Group) IsGroupResolvingResult() {}

type GroupCreateInput struct {
	Name string `json:"name"`
}

type GroupCreateOk struct {
	Group *Group `json:"group"`
}

func (GroupCreateOk) IsGroupCreateResult() {}

type GroupFindOk struct {
	Group *Group  `json:"group"`
	Users []*User `json:"users"`
}

func (GroupFindOk) IsGroupFindResult() {}

type GroupMutation struct {
	Create GroupCreateResult `json:"create"`
}

type GroupQuery struct {
	FindByUUID GroupFindResult `json:"findByUuid"`
}

type InternalErrorProblem struct {
	Message string `json:"message"`
}

func (InternalErrorProblem) IsGroupResolvingResult() {}
func (InternalErrorProblem) IsGroupCreateResult()    {}
func (InternalErrorProblem) IsGroupFindResult()      {}
func (InternalErrorProblem) IsProblemInterface()     {}
func (InternalErrorProblem) IsTokenResolvingResult() {}
func (InternalErrorProblem) IsUserResolvingResult()  {}
func (InternalErrorProblem) IsUserCreateResult()     {}
func (InternalErrorProblem) IsUserSignInResult()     {}
func (InternalErrorProblem) IsUserFindResult()       {}

type NotFoundProblem struct {
	Message string `json:"message"`
}

func (NotFoundProblem) IsGroupFindResult()  {}
func (NotFoundProblem) IsProblemInterface() {}
func (NotFoundProblem) IsUserFindResult()   {}

type Token struct {
	AccessToken string `json:"accessToken"`
}

func (Token) IsTokenResolvingResult() {}

type User struct {
	ID       int    `json:"id"`
	Username string `json:"username"`
	Password string `json:"password"`
	Email    string `json:"email"`
	Role     Role   `json:"role"`
}

func (User) IsUserResolvingResult() {}

type UserCreateInput struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Role     Role   `json:"role"`
}

type UserCreateOk struct {
	User *User `json:"user"`
}

func (UserCreateOk) IsUserCreateResult() {}

type UserFindOk struct {
	User *User `json:"user"`
}

func (UserFindOk) IsUserFindResult() {}

type UserMutation struct {
	Create UserCreateResult `json:"create"`
	SignIn UserSignInResult `json:"signIn"`
}

type UserQuery struct {
	FindByID *User `json:"findById"`
}

type UserSignInInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type UserSignOk struct {
	User  *User  `json:"user"`
	Token *Token `json:"token"`
}

func (UserSignOk) IsUserSignInResult() {}

type ValidationErrorProblem struct {
	Message string `json:"message"`
}

func (ValidationErrorProblem) IsProblemInterface() {}
func (ValidationErrorProblem) IsUserCreateResult() {}

type Role string

const (
	RoleAdmin  Role = "Admin"
	RoleClient Role = "Client"
)

var AllRole = []Role{
	RoleAdmin,
	RoleClient,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleAdmin, RoleClient:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
